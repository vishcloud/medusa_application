"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.medusaIntegrationTestRunner = medusaIntegrationTestRunner;
const utils_1 = require("@medusajs/framework/utils");
const awilix_1 = require("awilix");
const database_1 = require("./database");
const medusa_test_runner_utils_1 = require("./medusa-test-runner-utils");
function medusaIntegrationTestRunner({ moduleName, dbName, medusaConfigFile, schema = "public", env = {}, debug = false, inApp = false, testSuite, }) {
    const tempName = parseInt(process.env.JEST_WORKER_ID || "1");
    moduleName = moduleName ?? Math.random().toString(36).substring(7);
    dbName ??= `medusa-${moduleName.toLowerCase()}-integration-${tempName}`;
    let dbConfig = {
        dbName,
        clientUrl: (0, database_1.getDatabaseURL)(dbName),
        schema,
        debug,
    };
    const cwd = medusaConfigFile ?? process.cwd();
    let shutdown = async () => void 0;
    const dbUtils = (0, database_1.dbTestUtilFactory)();
    let globalContainer;
    let apiUtils;
    let loadedApplication;
    let options = {
        api: new Proxy({}, {
            get: (target, prop) => {
                return apiUtils[prop];
            },
        }),
        dbConnection: new Proxy({}, {
            get: (target, prop) => {
                return dbUtils.pgConnection_[prop];
            },
        }),
        getMedusaApp: () => loadedApplication,
        getContainer: () => globalContainer,
        dbConfig: {
            dbName,
            schema,
            clientUrl: dbConfig.clientUrl,
        },
        dbUtils,
    };
    let isFirstTime = true;
    const beforeAll_ = async () => {
        await (0, medusa_test_runner_utils_1.configLoaderOverride)(cwd, dbConfig);
        (0, medusa_test_runner_utils_1.applyEnvVarsToProcess)(env);
        const { logger, container, MedusaAppLoader } = await import("@medusajs/framework");
        const appLoader = new MedusaAppLoader();
        container.register({
            [utils_1.ContainerRegistrationKeys.LOGGER]: (0, awilix_1.asValue)(logger),
        });
        try {
            console.log(`Creating database ${dbName}`);
            await dbUtils.create(dbName);
            dbUtils.pgConnection_ = await (0, medusa_test_runner_utils_1.initDb)();
        }
        catch (error) {
            console.error("Error initializing database", error?.message);
            throw error;
        }
        console.log(`Migrating database with core migrations and links ${dbName}`);
        await (0, medusa_test_runner_utils_1.migrateDatabase)(appLoader);
        await (0, medusa_test_runner_utils_1.syncLinks)(appLoader, cwd, container);
        await (0, medusa_test_runner_utils_1.clearInstances)();
        let containerRes = container;
        let serverShutdownRes;
        let portRes;
        loadedApplication = await appLoader.load();
        try {
            const { shutdown = () => void 0, container: appContainer, port, } = await (0, medusa_test_runner_utils_1.startApp)({
                cwd,
                env,
            });
            containerRes = appContainer;
            serverShutdownRes = shutdown;
            portRes = port;
        }
        catch (error) {
            console.error("Error starting the app", error?.message);
            throw error;
        }
        /**
         * Run application migrations and sync links when inside
         * an application
         */
        if (inApp) {
            console.log(`Migrating database with core migrations and links ${dbName}`);
            await (0, medusa_test_runner_utils_1.migrateDatabase)(appLoader);
            await (0, medusa_test_runner_utils_1.syncLinks)(appLoader, cwd, containerRes);
        }
        const { default: axios } = (await import("axios"));
        const cancelTokenSource = axios.CancelToken.source();
        globalContainer = containerRes;
        shutdown = async () => {
            await serverShutdownRes();
            cancelTokenSource.cancel("Request canceled by shutdown");
        };
        apiUtils = axios.create({
            baseURL: `http://localhost:${portRes}`,
            cancelToken: cancelTokenSource.token,
        });
    };
    const beforeEach_ = async () => {
        // The beforeAll already run everything, so lets not re run the loaders for the first iteration
        if (isFirstTime) {
            isFirstTime = false;
            return;
        }
        const container = options.getContainer();
        const copiedContainer = (0, utils_1.createMedusaContainer)({}, container);
        try {
            const { MedusaAppLoader } = await import("@medusajs/framework");
            const medusaAppLoader = new MedusaAppLoader({
                container: copiedContainer,
            });
            await medusaAppLoader.runModulesLoader();
        }
        catch (error) {
            console.error("Error runner modules loaders", error?.message);
            throw error;
        }
    };
    const afterEach_ = async () => {
        try {
            await dbUtils.teardown({ schema });
        }
        catch (error) {
            console.error("Error tearing down database:", error?.message);
            throw error;
        }
    };
    return describe("", () => {
        beforeAll(beforeAll_);
        beforeEach(beforeEach_);
        afterEach(afterEach_);
        afterAll(async () => {
            await dbUtils.shutdown(dbName);
            await shutdown();
        });
        testSuite(options);
    });
}
//# sourceMappingURL=medusa-test-runner.js.map