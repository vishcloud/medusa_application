"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitSubscribersExecution = void 0;
// Allows you to wait for all subscribers to execute for a given event. Only works with the local event bus.
const waitSubscribersExecution = (eventName, eventBus) => {
    const eventEmitter = eventBus.eventEmitter_;
    const subscriberPromises = [];
    const originalListeners = eventEmitter.listeners(eventName);
    // If there are no existing listeners, resolve once the event happens. Otherwise, wrap the existing subscribers in a promise and resolve once they are done.
    if (!eventEmitter.listeners(eventName).length) {
        let ok;
        const promise = new Promise((resolve) => {
            ok = resolve;
        });
        subscriberPromises.push(promise);
        eventEmitter.on(eventName, ok);
    }
    else {
        eventEmitter.listeners(eventName).forEach((listener) => {
            eventEmitter.removeListener(eventName, listener);
            let ok, nok;
            const promise = new Promise((resolve, reject) => {
                ok = resolve;
                nok = reject;
            });
            subscriberPromises.push(promise);
            const newListener = async (...args2) => {
                return await listener.apply(eventBus, args2).then(ok).catch(nok);
            };
            eventEmitter.on(eventName, newListener);
        });
    }
    return Promise.all(subscriberPromises).finally(() => {
        eventEmitter.removeAllListeners(eventName);
        originalListeners.forEach((listener) => {
            eventEmitter.on(eventName, listener);
        });
    });
};
exports.waitSubscribersExecution = waitSubscribersExecution;
//# sourceMappingURL=events.js.map